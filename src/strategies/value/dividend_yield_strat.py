# trading_system/src/strategies/dividend_yield_strategy.py

import pandas as pd
import numpy as np
from typing import Dict, Optional, Union, List
from datetime import datetime

from src.strategies.base_strat import BaseStrategy, DataRetrievalError


class DividendYieldStrategy(BaseStrategy):
    """
    Vectorized Dividend Yield strategy implementation using financial statements.

    This strategy computes key fundamental metrics based on merged financial statement data
    (balance sheet, income statement, cash flow) and historical price data for multiple tickers.
    Trading signals are generated by evaluating the following criteria:
      - Market capitalization exceeds a minimum threshold
      - Dividend yield exceeds a minimum threshold
      - Payout ratio is below a maximum threshold
      - The company has paid dividends during a minimum number of distinct years
      - Dividend per share shows positive growth over prior periods

    The final signal is based on the sum of criteria met relative to a given threshold.
    All calculations are performed using vectorized operations for speed.

    Parameters:
        min_market_cap (float): Minimum market cap required.
        min_dividend_yield (float): Minimum dividend yield required.
        max_payout_ratio (float): Maximum acceptable dividend payout ratio.
        min_years_dividend (int): Minimum number of distinct years with dividend payments.
        min_criteria_met (int): Minimum number of individual criteria that must be met to generate a buy signal.
    """

    def __init__(self, db_config, params: Optional[Dict] = None):
        super().__init__(db_config, params)
        self.params = params or {
            'min_market_cap': 500e6,
            'min_dividend_yield': 0.03,
            'max_payout_ratio': 0.75,
            'min_years_dividend': 3,
            'min_criteria_met': 3
        }

    def generate_signals(self, tickers: Union[str, List[str]],
                         start_date: Optional[str] = None,
                         end_date: Optional[str] = None,
                         initial_position: int = 0,
                         latest_only: bool = False) -> pd.DataFrame:
        """
        Generate trading signals for one or more tickers based on historical financial statement data.

        Args:
            tickers (str or List[str]): Single ticker symbol or list of ticker symbols.
            start_date (str, optional): Not used, maintained for base class compatibility.
            end_date (str, optional): Not used, maintained for base class compatibility.
            initial_position (int): Starting position (unused).
            latest_only (bool): If True, returns only the most recent signal per ticker.

        Returns:
            pd.DataFrame: DataFrame containing signals and associated financial metrics.
        """
        try:
            # Ensure tickers is a list for uniform processing.
            if isinstance(tickers, str):
                tickers = [tickers]

            # Retrieve merged financial data for all tickers
            financial_data = self._get_merged_financials(tickers)
            if financial_data.empty:
                return pd.DataFrame()

            # Calculate financial metrics
            metrics = self._calculate_metrics(financial_data)

            # Calculate criteria flags and aggregate criteria met
            signals = self._calculate_criteria(metrics)

            # Format the final output containing key metrics and signals
            results = self._format_output(signals)
            if latest_only:
                # Return only the latest signal for each ticker.
                results = results.sort_values('date').groupby('ticker', as_index=False).last()
            return results

        except DataRetrievalError as e:
            self.logger.error(f"Data error for tickers {tickers}: {str(e)}")
            return pd.DataFrame()
        except Exception as e:
            self.logger.error(f"Processing error for tickers {tickers}: {str(e)}")
            return pd.DataFrame()

    def _get_merged_financials(self, tickers: List[str]) -> pd.DataFrame:
        """
        Merge balance sheet, income statement, cash flow, and historical price data for given tickers.

        Args:
            tickers (List[str]): List of ticker symbols.

        Returns:
            pd.DataFrame: DataFrame with merged financial statement metrics along with historical close prices.
        """
        # Retrieve financial statements for all tickers
        bs = self.get_financials(tickers, 'balance_sheet', lookback=None)
        is_ = self.get_financials(tickers, 'income_statement', lookback=None)
        cf = self.get_financials(tickers, 'cash_flow', lookback=None)

        # Reset indexes so that both 'ticker' and 'date' are available
        bs = bs.reset_index() if 'ticker' not in bs.columns else bs.reset_index()
        is_ = is_.reset_index() if 'ticker' not in is_.columns else is_.reset_index()
        cf = cf.reset_index() if 'ticker' not in cf.columns else cf.reset_index()

        # Select required columns and standardize names:
        # - Balance sheet: use ordinary_shares_number for shares outstanding.
        # - Income statement: use net_income.
        # - Cash flow: use cash_dividends_paid.
        bs = bs[['ticker', 'date', 'ordinary_shares_number']]
        is_ = is_[['ticker', 'date', 'net_income']]
        cf = cf[['ticker', 'date', 'cash_dividends_paid']]

        # Merge the three financial statements on ticker and date (inner join)
        merged = pd.merge(bs, is_, on=['ticker', 'date'], how='inner')
        merged = pd.merge(merged, cf, on=['ticker', 'date'], how='inner')

        # Convert date to datetime
        merged['date'] = pd.to_datetime(merged['date'])

        # Retrieve historical prices for the tickers
        prices = self.get_historical_prices(tickers, lookback=0)
        prices = prices.reset_index()  # Expect columns: ticker, date, close, etc.
        prices['date'] = pd.to_datetime(prices['date'])

        # Merge financials with prices using merge_asof by 'ticker' on date
        merged = merged.sort_values('date')
        prices = prices.sort_values('date')
        merged = pd.merge_asof(
            merged.sort_values('date'),
            prices[['ticker', 'date', 'close']].sort_values('date'),
            on='date',
            by='ticker',
            direction='nearest'
        )
        # Drop any rows with missing values after the merge
        merged = merged.dropna().reset_index(drop=True)
        return merged

    def _calculate_metrics(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate key financial metrics based on merged financial statement and price data.

        Calculated metrics include:
          - shares_outstanding: Derived from ordinary_shares_number.
          - dividend_paid: Absolute cash dividends paid.
          - dividend_per_share: Dividend paid divided by shares outstanding.
          - eps: Earnings per share calculated from net income.
          - market_cap: Market cap calculated as shares_outstanding * close price.
          - dividend_yield: Dividend yield (dividend per share / close price).
          - payout_ratio: Dividend payout ratio (dividend per share / EPS, where EPS > 0).
          - cumulative_div_years: Cumulative count of unique years (from statement dates) with dividend payments.
          - div_growth: Dividend per share growth percentage over the previous 4 periods (per ticker).

        Args:
            data (pd.DataFrame): Merged financials DataFrame.

        Returns:
            pd.DataFrame: DataFrame with additional computed metric columns.
        """
        df = data.copy()
        # Use ordinary_shares_number as shares outstanding
        df['shares_outstanding'] = df['ordinary_shares_number']

        # Calculate dividend-related metrics
        df['dividend_paid'] = df['cash_dividends_paid'].abs()
        df['dividend_per_share'] = df['dividend_paid'] / df['shares_outstanding']

        # EPS calculation from net income
        df['eps'] = df['net_income'] / df['shares_outstanding']

        # Market capitalization
        df['market_cap'] = df['shares_outstanding'] * df['close']

        # Dividend yield: dividend per share divided by the close price
        df['dividend_yield'] = df['dividend_per_share'] / df['close']

        # Payout ratio: dividend per share divided by EPS (only if EPS > 0)
        df['payout_ratio'] = np.where(
            df['eps'] > 0,
            df['dividend_per_share'] / df['eps'],
            np.nan
        )

        # Compute cumulative unique dividend years per ticker.
        # We count a year if dividend_per_share > 0 for that statement date.
        df['year'] = df['date'].dt.year
        df = df.sort_values(['ticker', 'date'])

        def cum_unique_div_years(grp):
            unique_years = set()
            cum_years = []
            for _, row in grp.iterrows():
                if row['dividend_per_share'] > 0:
                    unique_years.add(row['year'])
                cum_years.append(len(unique_years))
            return pd.Series(cum_years, index=grp.index)

        df['cumulative_div_years'] = df.groupby('ticker', group_keys=False).apply(cum_unique_div_years)

        # Dividend growth: percentage change in dividend per share over the previous 4 periods (per ticker)
        df['div_growth'] = df.groupby('ticker')['dividend_per_share'].pct_change(periods=4).fillna(0)

        return df.dropna(subset=['shares_outstanding', 'close'])

    def _calculate_criteria(self, metrics: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate criteria for generating a buy signal using computed financial metrics.

        Criteria evaluated per statement date:
          - Market cap exceeds minimum threshold.
          - Dividend yield meets/exceeds minimum threshold.
          - Payout ratio is less than or equal to the maximum allowed.
          - Cumulative dividend years meets/exceeds minimum requirement.
          - Dividend growth is positive.

        The total number of criteria met is summed, and later a buy signal is issued if this sum
        meets or exceeds a preconfigured threshold.

        Args:
            metrics (pd.DataFrame): DataFrame containing computed financial metrics.

        Returns:
            pd.DataFrame: DataFrame augmented with boolean criteria flags and a total criteria count.
        """
        df = metrics.copy()
        params = self.params

        # Market cap criteria
        df['market_cap_met'] = df['market_cap'] >= params['min_market_cap']

        # Dividend yield criteria
        df['yield_met'] = df['dividend_yield'] >= params['min_dividend_yield']

        # Payout ratio criteria
        df['payout_met'] = df['payout_ratio'] <= params['max_payout_ratio']

        # Dividend history criteria (unique years with dividend payments)
        df['history_met'] = df['cumulative_div_years'] >= params['min_years_dividend']

        # Dividend growth criteria: positive growth percentage indicator
        df['growth_met'] = (df['div_growth'] > 0).astype(int)

        # Total criteria met count (convert booleans to int for summing)
        criteria_cols = ['market_cap_met', 'yield_met', 'payout_met', 'history_met', 'growth_met']
        df['criteria_met'] = df[criteria_cols].astype(int).sum(axis=1)
        return df

    def _format_output(self, signals: pd.DataFrame) -> pd.DataFrame:
        """
        Format the final output DataFrame with selected columns and a trading signal based on criteria met.

        Output DataFrame includes:
          - Ticker, date, market cap, dividend yield, payout ratio,
          - Cumulative dividend years, total criteria met,
          - An overall signal flag (1 if criteria_met meets or exceeds the threshold, 0 otherwise),
          - And individual criteria flags.

        Args:
            signals (pd.DataFrame): DataFrame with computed metrics and criteria flags.

        Returns:
            pd.DataFrame: Formatted output DataFrame ready for downstream processing.
        """
        output = pd.DataFrame({
            'ticker': signals['ticker'],
            'date': signals['date'],
            'market_cap': signals['market_cap'],
            'dividend_yield': signals['dividend_yield'],
            'payout_ratio': signals['payout_ratio'],
            'years_with_dividends': signals['cumulative_div_years'],
            'criteria_met': signals['criteria_met'],
            'signal': (signals['criteria_met'] >= self.params['min_criteria_met']).astype(int)
        })

        # Append individual criteria flags (those columns ending in '_met')
        criteria_flags = signals.filter(regex='_met$').copy()
        output = pd.concat([output, criteria_flags], axis=1)
        return output.sort_values(['ticker', 'date']).reset_index(drop=True)