# trading_system/src/strategies/risk_management.py

"""
Risk Management Module for Trading Strategies.

This module provides the RiskManager class, designed to apply sophisticated risk
management rules to trading signals generated by algorithmic strategies. It incorporates:
- Stop-Loss: Exiting a position if the price moves unfavorably beyond a predefined threshold.
- Take-Profit: Exiting a position when the price reaches a predefined profit target.
- Trailing Stop-Loss: Adjusting the stop-loss level dynamically based on favorable price
  movements to lock in profits while allowing room for further gains.
- Slippage: Simulating the potential difference between the expected trade price and the
  actual execution price.
- Transaction Costs: Simulating brokerage fees or other costs associated with executing trades.

The implementation is fully vectorized using Pandas and NumPy for computational efficiency,
making it suitable for backtesting large datasets. It correctly handles both long and
short positions and calculates realized returns and cumulative portfolio value based on
risk-managed exits.

Core Logic:
1. Determines the intended trading position based on input signals.
2. Calculates entry prices, adjusted for slippage and transaction costs, when a new
   trade is initiated.
3. Establishes fixed stop-loss and take-profit price levels based on the entry price.
4. If enabled, calculates dynamic trailing stop-loss levels based on the highest high (for longs)
   or lowest low (for shorts) reached since the trade entry.
5. Monitors daily high/low prices to check for breaches of stop-loss, take-profit, or
   trailing stop levels.
6. Identifies exits triggered by signal reversals or moves to a neutral state.
7. Calculates the exit price, adjusted for slippage and transaction costs, based on the
   specific exit condition met (e.g., exit at stop level, target level, or closing price).
8. Computes the realized return for each closed trade.
9. Tracks the resulting position after applying exits (0 if exited, otherwise the intended position).
10. Calculates the cumulative return based on the sequence of realized trades.

Usage:
    Initialize the RiskManager with desired risk parameters (percentages for stops,
    profit targets, costs, etc.). Then, call its `apply()` method, passing a
    Pandas DataFrame containing pricing data ('high', 'low', 'close') and the
    strategy's raw trading signals ('signal'). The method returns an augmented
    DataFrame with risk-managed positions, returns, and exit details.
"""

import pandas as pd
import numpy as np
import logging
from typing import Dict, Optional

# Initialize module logger
logger = logging.getLogger(__name__)

class RiskManager:
    """
    Applies risk management rules to trading signals, including stops, targets,
    costs, and trailing stops, calculating risk-adjusted returns.

    This class processes a DataFrame of trading signals and price data, adjusting
    positions and calculating performance based on predefined risk parameters.
    It uses vectorized operations for efficiency.

    Attributes:
        stop_loss_pct (float): The fractional distance below the entry price (for longs)
            or above the entry price (for shorts) to trigger a stop-loss exit.
            Example: 0.05 represents a 5% stop-loss. Must be positive.
        take_profit_pct (float): The fractional distance above the entry price (for longs)
            or below the entry price (for shorts) to trigger a take-profit exit.
            Example: 0.10 represents a 10% take-profit. Must be positive.
        trailing_stop_pct (float): The fractional distance from the peak high (for longs)
            or trough low (for shorts) reached during the trade, below/above which
            the price must not fall/rise to avoid a trailing stop exit.
            Example: 0.03 represents a 3% trailing stop. Set to 0 or None to disable.
            Must be positive if used.
        slippage_pct (float): Estimated slippage cost per transaction (entry or exit)
            as a fraction of the price. Added to entry price for longs, subtracted
            for shorts. Subtracted from exit price for longs, added for shorts.
            Example: 0.001 represents 0.1% slippage.
        transaction_cost_pct (float): Estimated transaction cost per transaction
            (entry or exit) as a fraction of the price. Applied similarly to slippage.
            Example: 0.001 represents 0.1% transaction cost.

    Raises:
        ValueError: If percentage parameters (stop_loss, take_profit, trailing_stop)
                    are negative.
    """

    def __init__(self,
                 stop_loss_pct: float = 0.05,
                 take_profit_pct: float = 0.10,
                 trailing_stop_pct: Optional[float] = 0.0,
                 slippage_pct: float = 0.001,
                 transaction_cost_pct: float = 0.001):
        """
        Initializes the RiskManager with specified risk and cost parameters.

        Args:
            stop_loss_pct (float): Stop-loss percentage (e.g., 0.05 for 5%). Must be >= 0.
            take_profit_pct (float): Take-profit percentage (e.g., 0.10 for 10%). Must be >= 0.
            trailing_stop_pct (Optional[float]): Trailing stop percentage (e.g., 0.03 for 3%).
                                                 Set to 0 or None to disable. Must be >= 0 if provided.
            slippage_pct (float): Slippage estimate per transaction (e.g., 0.001 for 0.1%).
            transaction_cost_pct (float): Transaction cost estimate per transaction (e.g., 0.001 for 0.1%).

        Raises:
            ValueError: If stop_loss_pct, take_profit_pct, or trailing_stop_pct are negative.
        """
        if stop_loss_pct < 0:
            raise ValueError("stop_loss_pct cannot be negative.")
        if take_profit_pct < 0:
            raise ValueError("take_profit_pct cannot be negative.")
        if trailing_stop_pct is not None and trailing_stop_pct < 0:
            raise ValueError("trailing_stop_pct cannot be negative.")
        if trailing_stop_pct is None:
             trailing_stop_pct = 0.0 # Internally treat None as 0

        self.stop_loss_pct = stop_loss_pct
        self.take_profit_pct = take_profit_pct
        self.trailing_stop_pct = trailing_stop_pct
        self.slippage_pct = slippage_pct
        self.transaction_cost_pct = transaction_cost_pct

        # Combine slippage and transaction costs for simpler application
        self._entry_cost_factor = self.slippage_pct + self.transaction_cost_pct
        self._exit_cost_factor = self.slippage_pct + self.transaction_cost_pct

        logger.info(f"RiskManager initialized with: SL={stop_loss_pct:.2%}, TP={take_profit_pct:.2%}, "
                    f"TSL={'{:.2%}'.format(trailing_stop_pct) if trailing_stop_pct > 0 else 'Disabled'}, "
                    f"Slip={slippage_pct:.3%}, Cost={transaction_cost_pct:.3%}")


    def apply(self, signals_df: pd.DataFrame, initial_position: int = 0) -> pd.DataFrame:
        """
        Applies risk management rules to the signals DataFrame and computes results.

        Processes the input DataFrame (which must contain 'signal', 'high', 'low', 'close'
        columns indexed by datetime) to determine trade entries, exits based on stop-loss,
        take-profit, trailing stops, and signal changes, while accounting for simulated
        slippage and transaction costs.

        Args:
            signals_df (pd.DataFrame): DataFrame indexed by date/time, containing at least:
                - 'signal': The raw trading signal (-1 for short, 0 for hold/exit, 1 for long).
                - 'close': The closing price for the period.
                - 'high': The highest price reached during the period.
                - 'low': The lowest price reached during the period.
                It's assumed the signal for time 't' is generated based on data up to 't-1'
                and dictates the target position held during period 't'.
            initial_position (int): The starting position before the first signal in the
                                    DataFrame (0, 1, or -1). Default is 0.

        Returns:
            pd.DataFrame: A DataFrame with the original columns plus:
                - 'position': The risk-managed position held at the end of each period
                              (1 for long, -1 for short, 0 for flat). This reflects exits.
                - 'return': The realized fractional return for a trade if an exit occurred
                            during the period, otherwise 0. Calculated based on entry and
                            exit prices including costs/slippage.
                - 'cumulative_return': The cumulative fractional return based on the
                                       compounded returns of closed trades. Starts at 0.
                - 'exit_type': A string indicating the reason for an exit if one occurred:
                               'stop_loss', 'take_profit', 'trailing_stop', 'signal_exit',
                               or 'none'.

        Raises:
            ValueError: If required columns are missing from `signals_df`.
            TypeError: If `signals_df` index is not a DatetimeIndex.
        """
        required_cols = ['signal', 'close', 'high', 'low']
        if not all(col in signals_df.columns for col in required_cols):
            missing = [col for col in required_cols if col not in signals_df.columns]
            raise ValueError(f"Input DataFrame is missing required columns: {missing}")

        if not isinstance(signals_df.index, pd.DatetimeIndex):
             raise TypeError("Input DataFrame index must be a DatetimeIndex.")

        if signals_df.empty:
            logger.warning("Input DataFrame is empty. Returning empty DataFrame.")
            # Define expected output columns for an empty frame
            output_cols = list(signals_df.columns) + ['position', 'return', 'cumulative_return', 'exit_type']
            return pd.DataFrame(columns=output_cols, index=signals_df.index)

        df = signals_df.copy()
        epsilon = 1e-9 # Small number to prevent division by zero

        # --- 1. Determine Intended Position & Entries ---
        # 'raw_position' represents the target position based *only* on the signal, before risk exits.
        # A signal=0 implies exiting any existing position.
        df['raw_position'] = df['signal'].replace(0, np.nan).ffill().fillna(initial_position)
        # If signal is 0, raw_position should be 0, overriding ffill.
        df.loc[df['signal'] == 0, 'raw_position'] = 0

        # Identify rows where a new trade is entered (position changes from 0 or reverses).
        # Shift raw_position to compare current state with the previous state.
        prev_raw_position = df['raw_position'].shift(1).fillna(initial_position)
        entry_mask = (
            (prev_raw_position == 0) & (df['raw_position'] != 0) |  # Entry from flat
            (prev_raw_position * df['raw_position'] < 0)            # Reversal (e.g., 1 to -1)
        )

        # --- 2. Calculate Entry Price (with Costs/Slippage) ---
        df['entry_price'] = np.nan
        # Apply entry cost factor: add for long, subtract for short
        df.loc[entry_mask, 'entry_price'] = df['close'] * (1 + df['raw_position'] * self._entry_cost_factor)

        # Handle initial state if starting with a position
        if initial_position != 0 and len(df) > 0:
             # Check if the first row wasn't already marked as an entry AND has a position
             if not entry_mask.iloc[0] and df.iloc[0]['raw_position'] != 0:
                  # Assume entry happened just before the start based on initial_position and first close
                  df.iat[0, df.columns.get_loc('entry_price')] = df.iloc[0]['close'] * (1 + initial_position * self._entry_cost_factor)
                  # Mark the first row as needing an entry price ffill if it wasn't an entry signal itself
                  if pd.isna(df.iloc[0]['entry_price']): # Redundant check? Maybe remove. Safety first.
                        df.iat[0, df.columns.get_loc('entry_price')] = df.iloc[0]['close'] * (1 + initial_position * self._entry_cost_factor)


        # Forward fill the entry price; it remains constant until the next entry event.
        df['entry_price'] = df['entry_price'].ffill()
        # If there's still no entry price (e.g., starts flat, never enters), fill with NaN or 0? NaN is safer.
        # df['entry_price'] = df['entry_price'].fillna(0) # Avoid if possible

        # --- 3. Calculate Stop-Loss and Take-Profit Levels ---
        df['stop_level'] = np.nan
        df['target_level'] = np.nan

        # For long positions (raw_position == 1):
        long_mask = df['raw_position'] == 1
        # Stop is below entry
        df.loc[long_mask, 'stop_level'] = df['entry_price'] * (1 - self.stop_loss_pct)
        # Target is above entry
        df.loc[long_mask, 'target_level'] = df['entry_price'] * (1 + self.take_profit_pct)

        # For short positions (raw_position == -1):
        short_mask = df['raw_position'] == -1
        # Stop is above entry
        df.loc[short_mask, 'stop_level'] = df['entry_price'] * (1 + self.stop_loss_pct)
        # Target is below entry
        df.loc[short_mask, 'target_level'] = df['entry_price'] * (1 - self.take_profit_pct)


        # --- 4. Calculate Trailing Stop-Loss Level (if enabled) ---
        if self.trailing_stop_pct > 0:
            # Identify unique trades to track peaks/troughs within each trade.
            # An 'entry_flag' marks the start of each new trade (including reversals).
            df['entry_flag'] = entry_mask
            # If starting with an initial position, the first row is the effective start of that trade.
            if initial_position != 0 and len(df) > 0 and not df.iloc[0]['entry_flag']:
                 df.iat[0, df.columns.get_loc('entry_flag')] = True

            # Assign a unique ID to each trade sequence. ID increases at each entry flag.
            # Only assign IDs where a position is held (raw_position != 0)
            df['trade_id'] = np.where(df['raw_position'] != 0, df['entry_flag'].cumsum(), np.nan)
            # Forward fill trade_id so all bars within a trade have the same ID.
            df['trade_id'] = df['trade_id'].ffill()

            # Calculate trailing stop levels dynamically within each trade group.
            df['trailing_stop_level'] = np.nan

            # For long trades: track cumulative max high since entry. Stop is max_high * (1 - TSL%).
            # Group by trade_id first, then calculate cummax within each group.
            if long_mask.any(): # Avoid groupby if no long positions exist
                df['cummax_high'] = df.loc[long_mask].groupby('trade_id')['high'].cummax()
                df.loc[long_mask, 'trailing_stop_level'] = df['cummax_high'] * (1 - self.trailing_stop_pct)

            # For short trades: track cumulative min low since entry. Stop is min_low * (1 + TSL%).
            if short_mask.any(): # Avoid groupby if no short positions exist
                 df['cummin_low'] = df.loc[short_mask].groupby('trade_id')['low'].cummin()
                 df.loc[short_mask, 'trailing_stop_level'] = df['cummin_low'] * (1 + self.trailing_stop_pct)

            # Determine trailing stop exit condition using daily low/high.
            # Long exit: low <= trailing_stop_level
            # Short exit: high >= trailing_stop_level
            trailing_stop_exit = (
                (long_mask & (df['low'] <= df['trailing_stop_level'])) |
                (short_mask & (df['high'] >= df['trailing_stop_level']))
            )
            # Fill NaN TSL exits with False (can happen if a position exists but TSL isn't calculated yet)
            trailing_stop_exit = trailing_stop_exit.fillna(False)
        else:
            # If TSL is disabled, create a Series of False for the exit condition.
            trailing_stop_exit = pd.Series(False, index=df.index)


        # --- 5. Identify All Exit Conditions ---
        # Note: We check against daily 'low' for long exits and 'high' for short exits,
        # simulating that the level could be hit at any point during the day.

        # Fixed Stop Loss Exit:
        stop_exit = (
            (long_mask & (df['low'] <= df['stop_level'])) |
            (short_mask & (df['high'] >= df['stop_level']))
        ).fillna(False) # FillNa in case levels are NaN early on

        # Take Profit Exit:
        target_exit = (
            (long_mask & (df['high'] >= df['target_level'])) |
            (short_mask & (df['low'] <= df['target_level']))
        ).fillna(False) # FillNa in case levels are NaN early on

        # Signal-Based Exit:
        # Exit if the previous position was non-zero AND the current signal is zero (exit)
        # OR the current signal is the reverse of the previous position.
        # Use prev_raw_position defined earlier.
        signal_exit_condition = (df['signal'] == 0) | (df['signal'] == -prev_raw_position)
        signal_exit = (prev_raw_position != 0) & signal_exit_condition
        signal_exit = signal_exit.fillna(False)


        # --- 6. Determine Final Exit Trigger and Type ---
        # Combine all exit conditions. The order in np.select matters if multiple
        # conditions are met on the same day. Priority: Trailing > Stop > Target > Signal.
        # This means if low hits both TSL and SL, TSL exit is recorded.
        exit_conditions = [trailing_stop_exit, stop_exit, target_exit, signal_exit]
        exit_labels = ['trailing_stop', 'stop_loss', 'take_profit', 'signal_exit']

        # The combined mask where *any* exit occurs.
        # Note: An entry for a reversal (e.g., 1 to -1) implicitly closes the '1' position.
        # The 'exit_mask' primarily identifies stops, targets, and signal-driven closures to flat (0).
        # The `position` update later handles the flattening.
        # We prioritize explicit risk exits over signal exits if they occur simultaneously.
        df['exit_type'] = np.select(exit_conditions, exit_labels, default='none')

        # Update the exit mask to reflect the prioritized decision.
        exit_mask = (df['exit_type'] != 'none')


        # --- 7. Calculate Exit Price (with Costs/Slippage) ---
        # Determine the price at which the exit is simulated to occur.

        # Define prices associated with each exit type:
        # - Stop Loss: Exit at the stop_level.
        # - Take Profit: Exit at the target_level.
        # - Trailing Stop: Exit at the trailing_stop_level (if enabled).
        # - Signal Exit: Exit at the 'close' price of the day the signal changes.

        # Apply exit cost factor: subtract for long, add for short cover.
        exit_price_conditions = [
            df['exit_type'] == 'trailing_stop', # Check TSL first due to priority
            df['exit_type'] == 'stop_loss',
            df['exit_type'] == 'take_profit',
            df['exit_type'] == 'signal_exit'
        ]

        exit_price_choices = []
        # Trailing Stop Exit Price (use trailing_stop_level)
        if self.trailing_stop_pct > 0:
            exit_price_choices.append(
                df['trailing_stop_level'] * (1 - prev_raw_position * self._exit_cost_factor)
            )
        else:
             exit_price_choices.append(np.nan) # Placeholder if TSL disabled

        # Stop Loss Exit Price (use stop_level)
        exit_price_choices.append(
            df['stop_level'] * (1 - prev_raw_position * self._exit_cost_factor)
        )
        # Take Profit Exit Price (use target_level)
        exit_price_choices.append(
            df['target_level'] * (1 - prev_raw_position * self._exit_cost_factor)
        )
        # Signal Exit Price (use close)
        exit_price_choices.append(
            df['close'] * (1 - prev_raw_position * self._exit_cost_factor)
        )

        df['exit_price'] = np.select(exit_price_conditions, exit_price_choices, default=np.nan)


        # --- 8. Calculate Realized Return on Exit ---
        # Return is calculated only when an exit event occurs (`exit_mask` is True).
        # Add epsilon to denominators for numerical stability.
        trade_return_long = (df['exit_price'] / (df['entry_price'] + epsilon)) - 1
        trade_return_short = (df['entry_price'] / (df['exit_price'] + epsilon)) - 1

        # Use prev_raw_position to determine if the exited trade was long or short.
        df['return'] = np.where(
            exit_mask & (prev_raw_position == 1), trade_return_long,
            np.where(exit_mask & (prev_raw_position == -1), trade_return_short, 0) # Return is 0 if no exit
        )
        # Ensure no NaNs in return column if exit/entry prices were NaN
        df['return'] = df['return'].fillna(0)


        # --- 9. Determine Final Position ---
        # Start with the raw intended position for the day.
        df['position'] = df['raw_position']
        # If an exit occurred *based on the previous day's position state*, set current position to 0.
        df.loc[exit_mask, 'position'] = 0
        # Ensure position is integer type
        df['position'] = df['position'].astype(int)


        # --- 10. Calculate Cumulative Return ---
        # Use a multiplier approach for compounding. Multiplier is 1 + return for the trade.
        # Multiplier = ExitPrice / EntryPrice (for long)
        # Multiplier = EntryPrice / ExitPrice (for short)
        # Multiplier = 1 if no exit occurred.
        trade_multiplier = np.where(
            exit_mask & (prev_raw_position == 1), df['exit_price'] / (df['entry_price'] + epsilon),
            np.where(exit_mask & (prev_raw_position == -1), df['entry_price'] / (df['exit_price'] + epsilon), 1)
        )
        # Handle potential NaN multipliers if prices were NaN
        trade_multiplier = np.nan_to_num(trade_multiplier, nan=1.0) # Replace NaN with 1 (no change)
        # Ensure multipliers are not zero or negative if prices were bad
        trade_multiplier = np.maximum(epsilon, trade_multiplier)

        # Calculate cumulative product of multipliers, then subtract 1 for return format.
        df['cumulative_return'] = trade_multiplier.cumprod() - 1


        # --- 11. Clean Up Temporary Columns ---
        cols_to_drop = ['raw_position', 'entry_price', 'stop_level', 'target_level', 'exit_price']
        if self.trailing_stop_pct > 0:
            # Only drop TSL helper columns if TSL was enabled
            cols_to_drop.extend(['entry_flag', 'trade_id', 'cummax_high', 'cummin_low', 'trailing_stop_level'])
        # Use errors='ignore' in case some columns didn't exist (e.g., cummax_high if no long trades)
        result_df = df.drop(columns=cols_to_drop, errors='ignore')

        # Select and order final output columns
        final_columns = list(signals_df.columns) + ['position', 'return', 'cumulative_return', 'exit_type']
        # Ensure all expected columns are present, even if originals were dropped
        for col in final_columns:
             if col not in result_df.columns:
                  result_df[col] = np.nan # Add missing column back if needed

        return result_df[final_columns]