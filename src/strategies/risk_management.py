# trading_system/src/strategies/risk_management.py

"""
Risk Management Module for Trading Strategies.

This module provides the RiskManager class, designed to apply sophisticated risk
management rules to trading signals generated by algorithmic strategies. It incorporates:
- Stop-Loss: Exiting a position if the price moves unfavorably beyond a predefined threshold.
- Take-Profit: Exiting a position when the price reaches a predefined profit target.
- Trailing Stop-Loss: Adjusting the stop-loss level dynamically based on favorable price
  movements to lock in profits while allowing room for further gains.
- Slippage: Simulating the potential difference between the expected trade price and the
  actual execution price.
- Transaction Costs: Simulating brokerage fees or other costs associated with executing trades.

The implementation is fully vectorized using Pandas and NumPy for computational efficiency,
making it suitable for backtesting large datasets. It correctly handles both long and
short positions and calculates realized returns and cumulative portfolio value based on
risk-managed exits.

Core Logic:
1. Determines the intended trading position based on input signals.
2. Calculates entry prices, adjusted for slippage and transaction costs, when a new
   trade is initiated.
3. Establishes fixed stop-loss and take-profit price levels based on the entry price.
4. If enabled, calculates dynamic trailing stop-loss levels based on the highest high (for longs)
   or lowest low (for shorts) reached since the trade entry.
5. Monitors daily high/low prices to check for breaches of stop-loss, take-profit, or
   trailing stop levels.
6. Identifies exits triggered by signal reversals or moves to a neutral state.
7. Calculates the exit price, adjusted for slippage and transaction costs, based on the
   specific exit condition met (e.g., exit at stop level, target level, or closing price).
8. Computes the realized return for each closed trade.
9. Tracks the resulting position after applying exits (0 if exited, otherwise the intended position).
10. Calculates the cumulative return based on the sequence of realized trades.

Usage:
    Initialize the RiskManager with desired risk parameters (percentages for stops,
    profit targets, costs, etc.). Then, call its `apply()` method, passing a
    Pandas DataFrame containing pricing data ('high', 'low', 'close') and the
    strategy's raw trading signals ('signal'). The method returns an augmented
    DataFrame with risk-managed positions, returns, and exit details.
"""

import logging
from typing import Dict, Optional, Union

import numpy as np
import pandas as pd

# Initialize module logger
logger = logging.getLogger(__name__)

class RiskManager:
    """
    Applies risk management rules to trading signals, including stops, targets,
    costs, and trailing stops, calculating risk-adjusted returns.

    This class processes a DataFrame of trading signals and price data, adjusting
    positions and calculating performance based on predefined risk parameters.
    It uses vectorized operations for efficiency.

    Attributes:
        stop_loss_pct (float): The fractional distance below the entry price (for longs)
            or above the entry price (for shorts) to trigger a stop-loss exit.
            Example: 0.05 represents a 5% stop-loss. Must be positive.
        take_profit_pct (float): The fractional distance above the entry price (for longs)
            or below the entry price (for shorts) to trigger a take-profit exit.
            Example: 0.10 represents a 10% take-profit. Must be positive.
        trailing_stop_pct (float): The fractional distance from the peak high (for longs)
            or trough low (for shorts) reached during the trade, below/above which
            the price must not fall/rise to avoid a trailing stop exit.
            Example: 0.03 represents a 3% trailing stop. Set to 0 or None to disable.
            Must be positive if used.
        slippage_pct (float): Estimated slippage cost per transaction (entry or exit)
            as a fraction of the price. Added to entry price for longs, subtracted
            for shorts. Subtracted from exit price for longs, added for shorts.
            Example: 0.001 represents 0.1% slippage.
        transaction_cost_pct (float): Estimated transaction cost per transaction
            (entry or exit) as a fraction of the price. Applied similarly to slippage.
            Example: 0.001 represents 0.1% transaction cost.

    Raises:
        ValueError: If percentage parameters (stop_loss, take_profit, trailing_stop)
                    are negative.
    """

    def __init__(self,
                 stop_loss_pct: float = 0.05,
                 take_profit_pct: float = 0.10,
                 trailing_stop_pct: Optional[float] = 0.0,
                 slippage_pct: float = 0.001,
                 transaction_cost_pct: float = 0.001):
        """
        Initializes the RiskManager with specified risk and cost parameters.

        Args:
            stop_loss_pct (float): Stop-loss percentage (e.g., 0.05 for 5%). Must be >= 0.
            take_profit_pct (float): Take-profit percentage (e.g., 0.10 for 10%). Must be >= 0.
            trailing_stop_pct (Optional[float]): Trailing stop percentage (e.g., 0.03 for 3%).
                                                 Set to 0 or None to disable. Must be >= 0 if provided.
            slippage_pct (float): Slippage estimate per transaction (e.g., 0.001 for 0.1%).
            transaction_cost_pct (float): Transaction cost estimate per transaction (e.g., 0.001 for 0.1%).

        Raises:
            ValueError: If stop_loss_pct, take_profit_pct, or trailing_stop_pct are negative.
        """
        if stop_loss_pct < 0:
            raise ValueError("stop_loss_pct cannot be negative.")
        if take_profit_pct < 0:
            raise ValueError("take_profit_pct cannot be negative.")
        if trailing_stop_pct is not None and trailing_stop_pct < 0:
            raise ValueError("trailing_stop_pct cannot be negative.")
        if trailing_stop_pct is None:
             trailing_stop_pct = 0.0 # Internally treat None as 0

        self.stop_loss_pct = stop_loss_pct
        self.take_profit_pct = take_profit_pct
        self.trailing_stop_pct = trailing_stop_pct
        self.slippage_pct = slippage_pct
        self.transaction_cost_pct = transaction_cost_pct

        # Combine slippage and transaction costs for simpler application
        self._entry_cost_factor = self.slippage_pct + self.transaction_cost_pct
        self._exit_cost_factor = self.slippage_pct + self.transaction_cost_pct

        logger.info(f"RiskManager initialized with: SL={stop_loss_pct:.2%}, TP={take_profit_pct:.2%}, "
                    f"TSL={'{:.2%}'.format(trailing_stop_pct) if trailing_stop_pct > 0 else 'Disabled'}, "
                    f"Slip={slippage_pct:.3%}, Cost={transaction_cost_pct:.3%}")


    def _apply_logic_single_ticker(self, df_single: pd.DataFrame, initial_position: int) -> pd.DataFrame:
        """Internal method with core RM logic for a single ticker."""

        # Minimal Check within the core logic (as requested)
        if not isinstance(df_single.index, pd.DatetimeIndex):
             # This ideally should be caught before calling this internal method
             logger.error(f"Internal RM logic received non-DatetimeIndex: {type(df_single.index)}. Returning input.")
             # Add error columns to signal failure
             df_single['position'] = initial_position
             df_single['return'] = 0.0
             df_single['cumulative_return'] = 0.0
             df_single['exit_type'] = 'error_bad_index_internal'
             return df_single

        # --- Start of calculation block (virtually identical to original apply) ---
        df = df_single.copy() # Operate on copy
        epsilon = 1e-9 # Small number to prevent division by zero

        # --- 1. Determine Intended Position & Entries ---
        df['raw_position'] = df['signal'].replace(0, np.nan).ffill().fillna(initial_position)
        df.loc[df['signal'] == 0, 'raw_position'] = 0
        prev_raw_position = df['raw_position'].shift(1).fillna(initial_position)
        entry_mask = (
            (prev_raw_position == 0) & (df['raw_position'] != 0) |
            (prev_raw_position * df['raw_position'] < 0)
        )

        # --- 2. Calculate Entry Price (with Costs/Slippage) ---
        df['entry_price'] = np.nan
        df.loc[entry_mask, 'entry_price'] = df['close'] * (1 + df['raw_position'] * self._entry_cost_factor)
        if initial_position != 0 and len(df) > 0:
             if not entry_mask.iloc[0] and df.iloc[0]['raw_position'] != 0:
                  df.iat[0, df.columns.get_loc('entry_price')] = df.iloc[0]['close'] * (1 + initial_position * self._entry_cost_factor)
                  if pd.isna(df.iloc[0]['entry_price']):
                        df.iat[0, df.columns.get_loc('entry_price')] = df.iloc[0]['close'] * (1 + initial_position * self._entry_cost_factor)
        df['entry_price'] = df['entry_price'].ffill()

        # --- 3. Calculate Stop-Loss and Take-Profit Levels ---
        df['stop_level'] = np.nan
        df['target_level'] = np.nan
        long_mask = df['raw_position'] == 1
        short_mask = df['raw_position'] == -1
        df.loc[long_mask, 'stop_level'] = df['entry_price'] * (1 - self.stop_loss_pct)
        df.loc[long_mask, 'target_level'] = df['entry_price'] * (1 + self.take_profit_pct)
        df.loc[short_mask, 'stop_level'] = df['entry_price'] * (1 + self.stop_loss_pct)
        df.loc[short_mask, 'target_level'] = df['entry_price'] * (1 - self.take_profit_pct)

        # --- 4. Calculate Trailing Stop-Loss Level (if enabled) ---
        trailing_stop_exit = pd.Series(False, index=df.index) # <<< Initialize default
        if self.trailing_stop_pct > 0:
            df['entry_flag'] = entry_mask
            if initial_position != 0 and len(df) > 0 and not df.iloc[0]['entry_flag']:
                 df.iat[0, df.columns.get_loc('entry_flag')] = True
            df['trade_id'] = np.where(df['raw_position'] != 0, df['entry_flag'].cumsum(), np.nan)
            df['trade_id'] = df['trade_id'].ffill()
            df['trailing_stop_level'] = np.nan
            if long_mask.any(): # Avoid groupby if no long positions exist
                # NO Groupby needed here as we are processing a single ticker's data
                df['cummax_high'] = df.loc[long_mask,'high'].cummax() # Use high directly
                df.loc[long_mask, 'trailing_stop_level'] = df['cummax_high'] * (1 - self.trailing_stop_pct)
            if short_mask.any(): # Avoid groupby if no short positions exist
                 df['cummin_low'] = df.loc[short_mask,'low'].cummin() # Use low directly
                 df.loc[short_mask, 'trailing_stop_level'] = df['cummin_low'] * (1 + self.trailing_stop_pct)
            trailing_stop_exit = (
                (long_mask & (df['low'] <= df['trailing_stop_level'])) |
                (short_mask & (df['high'] >= df['trailing_stop_level']))
            ).fillna(False) # <<< Apply fillna here
        # else: # No need for else block if initialized above
            # trailing_stop_exit = pd.Series(False, index=df.index)

        # --- 5. Identify All Exit Conditions ---
        stop_exit = (
            (long_mask & (df['low'] <= df['stop_level'])) |
            (short_mask & (df['high'] >= df['stop_level']))
        ).fillna(False)
        target_exit = (
            (long_mask & (df['high'] >= df['target_level'])) |
            (short_mask & (df['low'] <= df['target_level']))
        ).fillna(False)
        signal_exit_condition = (df['signal'] == 0) | (df['signal'] == -prev_raw_position)
        signal_exit = (prev_raw_position != 0) & signal_exit_condition
        signal_exit = signal_exit.fillna(False)

        # --- 6. Determine Final Exit Trigger and Type ---
        exit_conditions = [trailing_stop_exit, stop_exit, target_exit, signal_exit]
        exit_labels = ['trailing_stop', 'stop_loss', 'take_profit', 'signal_exit']
        df['exit_type'] = np.select(exit_conditions, exit_labels, default='none')
        exit_mask = (df['exit_type'] != 'none')

        # --- 7. Calculate Exit Price (with Costs/Slippage) ---
        exit_price_conditions = [
            df['exit_type'] == 'trailing_stop', # Check TSL first due to priority
            df['exit_type'] == 'stop_loss',
            df['exit_type'] == 'take_profit',
            df['exit_type'] == 'signal_exit'
        ]
        exit_price_choices = []
        if self.trailing_stop_pct > 0:
            exit_price_choices.append(
                df['trailing_stop_level'] * (1 - prev_raw_position * self._exit_cost_factor)
            )
        else:
             exit_price_choices.append(np.nan) # Placeholder if TSL disabled
        exit_price_choices.append(
            df['stop_level'] * (1 - prev_raw_position * self._exit_cost_factor)
        )
        exit_price_choices.append(
            df['target_level'] * (1 - prev_raw_position * self._exit_cost_factor)
        )
        exit_price_choices.append(
            df['close'] * (1 - prev_raw_position * self._exit_cost_factor)
        )
        df['exit_price'] = np.select(exit_price_conditions, exit_price_choices, default=np.nan)

        # --- 8. Calculate Realized Return on Exit ---
        trade_return_long = (df['exit_price'] / (df['entry_price'] + epsilon)) - 1
        trade_return_short = (df['entry_price'] / (df['exit_price'] + epsilon)) - 1
        raw_return = np.where(
            exit_mask & (prev_raw_position == 1), trade_return_long,
            np.where(exit_mask & (prev_raw_position == -1), trade_return_short, 0.0) # Use 0.0 for float consistency
        )

        # Now assign the numpy array to the DataFrame column
        df['return'] = raw_return
        # Then apply .fillna(0) to the *Pandas Series* df['return']
        df['return'] = df['return'].fillna(0.0)

        # --- 9. Determine Final Position ---
        df['position'] = df['raw_position']
        df.loc[exit_mask, 'position'] = 0
        df['position'] = df['position'].astype(int)

        # --- 10. Calculate Cumulative Return ---
        trade_multiplier = np.where(
            exit_mask & (prev_raw_position == 1), df['exit_price'] / (df['entry_price'] + epsilon),
            np.where(exit_mask & (prev_raw_position == -1), df['entry_price'] / (df['exit_price'] + epsilon), 1)
        )
        trade_multiplier = np.nan_to_num(trade_multiplier, nan=1.0) # Replace NaN with 1 (no change)
        trade_multiplier = np.maximum(epsilon, trade_multiplier)
        df['cumulative_return'] = trade_multiplier.cumprod() - 1

        # --- 11. Clean Up Temporary Columns ---
        cols_to_drop = ['raw_position', 'entry_price', 'stop_level', 'target_level', 'exit_price']
        if self.trailing_stop_pct > 0:
            cols_to_drop.extend(['entry_flag', 'trade_id', 'cummax_high', 'cummin_low', 'trailing_stop_level'])
        result_df = df.drop(columns=cols_to_drop, errors='ignore')

        # --- Select and order final output columns --- # <<< Slightly modified this part for clarity
        # Original columns from the input group + the RM output columns
        output_cols = ['position', 'return', 'cumulative_return', 'exit_type']
        # Combine original columns (excluding any output cols it might already have) and output cols
        original_cols_filtered = [col for col in df_single.columns if col not in output_cols]
        final_columns = original_cols_filtered + output_cols

        # Ensure all expected final columns are present
        for col in final_columns:
             if col not in result_df.columns:
                  result_df[col] = np.nan # Add missing column back if needed (e.g., if TSL disabled)

        return result_df[final_columns] # Return with consistent column order
    
    def apply(self,
              signals_df: pd.DataFrame,
              initial_position: Union[int, Dict[str, int]] = 0) -> pd.DataFrame:
        """
        Applies risk management rules to the signals DataFrame. Handles both
        single-ticker (DatetimeIndex) and multi-ticker (MultiIndex or 'ticker' column) inputs.

        Args:
            signals_df (pd.DataFrame): DataFrame indexed by date/time (single ticker)
                or MultiIndex ['ticker', 'date'] (multi-ticker), or containing a
                'ticker' column. Must contain 'signal', 'close', 'high', 'low'.
            initial_position (Union[int, Dict[str, int]]): The starting position.
                If int, applied to all tickers. If dict, maps ticker to its initial position. Default is 0.

        Returns:
            pd.DataFrame: A DataFrame with the original columns plus:
                - 'position': The risk-managed position held at the end of each period.
                - 'return': The realized fractional return for a trade if an exit occurred.
                - 'cumulative_return': The cumulative fractional return based on closed trades.
                - 'exit_type': A string indicating the reason for an exit.
                The index structure (DatetimeIndex or MultiIndex) of the input is preserved.

        Raises:
            ValueError: If required columns are missing or input format is unusable.
            TypeError: If initial_position type is invalid.
        """
        required_cols = ['signal', 'close', 'high', 'low']
        if not all(col in signals_df.columns for col in required_cols):
            missing = [col for col in required_cols if col not in signals_df.columns]
            raise ValueError(f"Input DataFrame is missing required columns: {missing}")

        if signals_df.empty:
            logger.warning("Input DataFrame to RiskManager is empty. Returning empty DataFrame.")
            # Define expected output columns for an empty frame
            output_cols = list(signals_df.columns) + ['position', 'return', 'cumulative_return', 'exit_type']
            return pd.DataFrame(columns=output_cols, index=signals_df.index)

        # --- Detect Input Format ---
        is_multi_index = isinstance(signals_df.index, pd.MultiIndex)
        has_ticker_col = 'ticker' in signals_df.columns

        # --- Dispatch based on Format ---
        if is_multi_index or has_ticker_col:
            # --- Multi-Ticker Processing ---
            logger.debug("RiskManager applying to multi-ticker input.")
            df_multi = signals_df.copy() # Work on a copy

            # Determine grouping factor and if index needs temporary reset
            if is_multi_index:
                # Assume 'ticker' is the first level name, or index 0 if unnamed
                ticker_level = df_multi.index.names[0] if df_multi.index.names[0] else 0
                group_by_factor = df_multi.index.get_level_values(ticker_level)
                input_index = df_multi.index # Preserve original index
                # We need DatetimeIndex within the apply function, so reset index before groupby
                df_multi = df_multi.reset_index()
                # Find the date column name (likely 'date' or level_1 if unnamed)
                date_col_name = input_index.names[1] if input_index.names[1] else f"level_{1}"
                if date_col_name not in df_multi.columns:
                     raise ValueError(f"Could not find date column '{date_col_name}' after resetting MultiIndex.")
                df_multi = df_multi.set_index(date_col_name) # Set date as index for processing
                if not isinstance(df_multi.index, pd.DatetimeIndex):
                     df_multi.index = pd.to_datetime(df_multi.index) # Ensure it's datetime

                group_col_name = input_index.names[0] if input_index.names[0] else f"level_{0}" # Get ticker col name
                if group_col_name not in df_multi.columns:
                     raise ValueError(f"Could not find ticker column '{group_col_name}' after resetting MultiIndex.")

            elif has_ticker_col:
                group_col_name = 'ticker'
                group_by_factor = df_multi[group_col_name]
                # Ensure index is DatetimeIndex
                if not isinstance(df_multi.index, pd.DatetimeIndex):
                     logger.warning(f"Multi-ticker input with 'ticker' column has non-DatetimeIndex: {type(df_multi.index)}. Assuming it contains dates.")
                     try:
                         df_multi.index = pd.to_datetime(df_multi.index)
                         if not isinstance(df_multi.index, pd.DatetimeIndex): raise ValueError("Conv failed")
                     except Exception as e:
                         raise TypeError(f"Failed to convert index to DatetimeIndex for 'ticker' column input: {e}")
                input_index = df_multi.index # Preserve original index
            else:
                 # This case should technically not be reached due to initial check
                 raise ValueError("Inconsistent state in RiskManager input format detection.")

            # Prepare initial positions dictionary
            if isinstance(initial_position, int):
                 unique_tickers = group_by_factor.unique()
                 initial_positions_dict = {ticker: initial_position for ticker in unique_tickers}
            elif isinstance(initial_position, dict):
                 initial_positions_dict = initial_position
            else:
                 raise TypeError("initial_position must be an int or a Dict[str, int]")

            # Define the function to apply to each group (which now has DatetimeIndex)
            def apply_logic_wrapper(group_df):
                # Get the ticker name (consistent across the group)
                ticker_name = group_df[group_col_name].iloc[0]
                ticker_initial_pos = initial_positions_dict.get(ticker_name, 0)
                # Call the core logic function
                # Drop the group_col_name before passing if it wasn't part of original MultiIndex levels
                group_to_process = group_df.drop(columns=[group_col_name], errors='ignore')
                return self._apply_logic_single_ticker(group_to_process, ticker_initial_pos)

            # Apply the wrapper using groupby on the ticker column
            all_results = df_multi.groupby(group_col_name, group_keys=True).apply(apply_logic_wrapper) # group_keys=True is default & helpful

            # --- Reconstruct original index if needed ---
            # The result 'all_results' will have a MultiIndex [ticker, date]
            # If the original input was MultiIndex, this is likely the desired output format.
            if is_multi_index:
                 # Ensure the names of the output index match the input index names
                 try:
                    all_results.index.names = input_index.names
                 except Exception as name_err:
                      logger.warning(f"Could not rename output MultiIndex levels: {name_err}")
                 result_df = all_results
            elif has_ticker_col:
                 # If original had 'ticker' column, reset index to get 'ticker' back as column
                 # and set the original DatetimeIndex back
                 ticker_index_name = all_results.index.names[0] # Name of the ticker level
                 result_df = all_results.reset_index()
                 # Find the date column name (likely index name from wrapper or default 'date')
                 date_col_from_index = all_results.index.names[1] if all_results.index.names[1] else 'date'
                 result_df = result_df.rename(columns={ticker_index_name: 'ticker', date_col_from_index: 'date_col_temp'})
                 result_df = result_df.set_index(pd.to_datetime(result_df['date_col_temp']))
                 result_df.index.name = input_index.name # Restore original index name
                 result_df = result_df.drop(columns=['date_col_temp'])
                 # Reorder columns potentially? For now, leave as is.
            else:
                 # Fallback - should not happen
                 result_df = all_results

        else:
            # --- Single-Ticker Processing ---
            logger.debug("RiskManager applying to single-ticker input.")
            if not isinstance(signals_df.index, pd.DatetimeIndex):
                 # This check is redundant if the multi-ticker logic is correct, but keep for safety
                 raise TypeError("Single-ticker input DataFrame index must be a DatetimeIndex.")

            # Handle initial position
            if isinstance(initial_position, dict):
                 logger.warning("Initial position dict provided for single ticker. Using 0.")
                 single_ticker_initial_pos = 0
            elif isinstance(initial_position, int):
                 single_ticker_initial_pos = initial_position
            else:
                 raise TypeError("initial_position must be int for single ticker input")

            # Directly call the core logic
            result_df = self._apply_logic_single_ticker(signals_df.copy(), single_ticker_initial_pos)

        return result_df